import java.util.LinkedHashSet;
import java.util.Scanner;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

public class coursework {
	
	public String node="";  //variable stores the given state 
	public int IndexOfblank; 
	public static LinkedHashSet<String> Set1 = new LinkedHashSet<>(); // used to store all the nodes generated by moving the blank tile
	public static LinkedHashSet<String> Set2 = new LinkedHashSet<>(); //Set 1 is used for S1 and Set used for S2
	public static LinkedHashSet<String> Set3= new LinkedHashSet<>();
	public static String[][] tree = new  String[182000][3]; //also stores the nodes and their unique index and parent index 
	public static String[][] tree2 = new  String[182000][3];//tree is used for S1 and tree 2 is used for S2
	public static int Nodecount=0, cpycount=0; //counters to create unique index 

	
	public static boolean isSafe(int blankindex) {  //this method checks if the blank tile  is moved within the bounds of the 3x3 grid
		return(blankindex >=0 && blankindex <=8 );
	}
	
	public static int blankIndex(String node) { //method returns the index of the blank tile in a given state;
		char[]ch = node.toCharArray();
		int index=0;
		for(int k=0; k<ch.length;k++) {
			if(ch[k]== '_') {
				index = k;
			}
		}
		return index;
	}
	public static boolean NodeAlreadyExists(String node, String setname) { //method check if the node created is already in the tree 
		if(setname.contains("Set2")) { //returns true if the node is already in the HashSet 
		return(Set2.contains(node));}else {
			return(Set1.contains(node)); //ensures only unique nodes are stored 
		}
	}
	
	public static void addNode(String newnode, int parentindex, String treename, String setname){ //method adds node to HashSet and 2D Array called tree
		if(!NodeAlreadyExists(newnode,setname)) { //calls method to check if node already in the tree 
			if(treename.contains("tree2")) {
				tree2[cpycount][0]=String.valueOf(cpycount); //each state added to tree given a unique index
				tree2[cpycount][1]=String.valueOf(parentindex); // also stores the index of its parent node 
				tree2[cpycount][2]=newnode; //stores the actual state of the node
				Set2.add(newnode); //adds only the state to the Hash set so it can quickly check if its already in the tree when another node is added as hashsets are faster 
				cpycount++;
			}else { //same concept for other set applied 
				tree[Nodecount][0]=String.valueOf(Nodecount);
				tree[Nodecount][1]=String.valueOf(parentindex);
				tree[Nodecount][2]=newnode;
				Set1.add(newnode);
				Nodecount++;
			}
		}
	}
	
	
	
	public static String  moveUP(int nodenum, String treename) { //method moves the blank tile up 
		String currentNode; 
		if(treename.contains("tree2")) {
		currentNode = tree2[nodenum][2]; //currentnode's state is retrieved from the Array which is the parent node that is used to generate its children nodes  
		}else{
		currentNode = tree[nodenum][2];
		}
		String newnode =currentNode; //new state created by copying the state of the parent node
		int blankI =blankIndex(newnode); //index of the blank found by calling the method
		if(isSafe(blankI-3)) { //moves blank up the matrix and checks if blank is within the bounds using method 
			char[] ch = newnode.toCharArray();//String broken down to set of characters 
			ch[blankI]= ch[blankI-3]; //letter and the blank tile is swapped 
			ch[blankI-3]='_';
			newnode=String.valueOf(ch); //character  array changed to string  
			return newnode; //new state returned 
		} else {
			return ""; //if blank tile cannot be moved up an empty string is returned 
		}
		
	}
	
	public static String moveDOWN(int nodenum, String treename) { //method moves the blank tile down 
		String currentNode; //uses same approach as the move up 
		if(treename.contains("tree2")) {
		currentNode = tree2[nodenum][2];
		}else{
		currentNode = tree[nodenum][2];}
		String newnode =currentNode;
		int blankI =blankIndex(newnode);
		if(isSafe(blankI+3)) {
			char[] ch = newnode.toCharArray();
			ch[blankI]= ch[blankI+3];
			ch[blankI+3]='_';
			newnode=String.valueOf(ch);
			return newnode;
		}else {
			return "";
		}
	}
	
	public static String moveRIGHT(int nodenum, String treename) {//method moves blank tile right
		String currentNode; 
		if(treename.contains("tree2")) { //checks which array to get  the current node from
		currentNode = tree2[nodenum][2];
		}else{
		currentNode = tree[nodenum][2];}
		String newnode =currentNode;
		int blankI =blankIndex(newnode);
		if(isSafe(blankI+1)&&(((blankI+1)%3)!=0)) { //moves blank tile right by 1 square and if it is on the edge then right move is not permitted 
			char[] ch = newnode.toCharArray();
			ch[blankI]= ch[blankI+1];
			ch[blankI+1]='_';
			newnode=String.valueOf(ch);
			return newnode;
		}else {
			return "";
		}
		
	}
	
	public static String moveLEFT(int nodenum, String treename) { //method moves blank tile left
		String currentNode;
		if(treename.contains("tree2")) {
		currentNode = tree2[nodenum][2];
		}else{
		currentNode = tree[nodenum][2];}
		String newnode =currentNode;
		int blankI =blankIndex(newnode);
		if(isSafe(blankI-1) && (blankI-1!=-1) &&(blankI-1!=2)&&(blankI-1!=5)) {//moves blank tile left by 1 square and if it is on the edge then left move is not permitted 
			char[] ch = newnode.toCharArray();
			ch[blankI]= ch[blankI-1];
			ch[blankI-1]='_';
			newnode=String.valueOf(ch);
			return newnode;
		} else {
			return "";
		}
	}
	public static void generateState(String initialstate, String treename, String setname) { //depth first method to generate all the nodes 
		 int currnode=0; //sets current node and root node index to 0
		 int rootnode=0;
		 addNode(initialstate,0,treename,setname); // add the root node onto the tree
		if(setname.contains("Set2")) { //runs algorithm for Set2 
			for(int i =0 ; i <= 181430; i++) { //loops 181430 to ensure  maximum possible unique nodes are created 
				//algorithm backtracks to the root node if child nodes cannot be created from the given parent 
				currnode= rootnode; //algorithm generates all the child nodes using a parent node initially uses the root node 
				String child = moveLEFT(currnode,treename); //Try to move the blank tile  left first until it cannot be moved left anymore
				if(child!="") {
					addNode(child,rootnode,treename,setname); // new nodes added to the tree and hash set ;
				}
				 child = moveRIGHT(currnode,treename); //when it cannot be moved left the blank tile is moved right until it cannot be moved right anymore
				 if(child!="") {
						addNode(child,rootnode,treename,setname);// new nodes added to the tree and hash set ;
					}
				 child = moveDOWN(currnode,treename);//when it cannot be moved right the blank tile is moved up until it cannot be moved up anymore
				 if(child!="") {
						 addNode(child,rootnode,treename,setname);// new nodes added to the tree and hash set ;
					}
				 child = moveUP(currnode,treename);//when it cannot be moved up the blank tile is moved down until it cannot be moved down anymore
				 if(child!="") {
						addNode(child,rootnode,treename,setname);// new nodes added to the tree and hash set ;
					}
				 //if blank tile cant be move left, right, up or down that means all the possible child nodes have been created using the parent node
				 rootnode= Integer.parseInt(tree2[rootnode+1][0]);} //the root node is set to the left most child node created 
				 
			}else {  //same approach used to create Set 2 
		
		for(int i =0 ; i <= 181430; i++) { 
			currnode= rootnode;
			String child = moveLEFT(currnode, treename);
			if(child!="") {
				addNode(child,rootnode,treename,setname);
			}
			 child = moveRIGHT(currnode,treename);
			 if(child!="") {
					addNode(child,rootnode,treename,setname);
				}
			 child = moveDOWN(currnode,treename);
			 if(child!="") {
					 addNode(child,rootnode,treename,setname);
				}
			 child = moveUP(currnode,treename);
			 if(child!="") {
					addNode(child,rootnode,treename,setname);
				}

				 rootnode= Integer.parseInt(tree[rootnode+1][0]); 
		} 

	}
	}
	public static void main(String[] args) throws IOException { //main to run the program
		Scanner myObj = new Scanner(System.in); 
		System.out.println("Enter R(S1)  :");
		String initialnode = myObj.nextLine(); //gets the S1 from user
		String treename="tree"; //set as initial state
		String setname="Set1";
		generateState(initialnode,treename,setname); //nodes generated using Depth first approach S1 and stored in Hash set
		
		
		
		System.out.println("Enter R(S2)  :");
		String initialnode2 =  myObj.nextLine(); //gets the S1 from user
		treename="tree2"; //set as S2
		setname="Set2";
		generateState(initialnode2,treename,setname);//nodes generated using Depth first approach for S2 and stored in Hash set
		
		System.out.println("|R(S1)|  ="+Set1.size()); //outputs the number of elements in HashSet which is the number of unique states produced
		System.out.println("|R(S2)|  ="+Set2.size());  //same for s2
		
		Iterator<String> l= Set1.iterator(); //loops through S1 and S2 to find which nodes exists in S1 but not in S2
		while(l.hasNext()) {
			if(!(Set2.contains(l.next()))) { //if they exist in S1 and not in S2 nodes added to Set3 hash set
				Set3.add(l.next());
			}
		}
		System.out.println("|R(S1)/R(S2)|  ="+Set3.size());  //Size of Set3 outputted ;
		
		
		System.out.println("------------------------------------------------"); //prints all states 
		System.out.println("States of R(S1)");
		Iterator<String> s1= Set1.iterator();
		while(s1.hasNext()) {
			System.out.println(s1.next());
		}
		System.out.println("------------------------------------------------");
		System.out.println("States of R(S2)");
		Iterator<String> s2= Set2.iterator();
		while(s2.hasNext()) {
			System.out.println(s2.next());
		} 
		System.out.println("------------------------------------------------");
		System.out.println("R(S1)/R(S2)");
		Iterator<String> s3= Set3.iterator();
		while(s3.hasNext()) {
			System.out.print(s3.next());
		}
		System.out.println("------------------------------------------------"); 
	} 

}
